# Вопросы для собеседования GO-разработчиков
## Middle

---
### 1. Какой размер пустого интерфейса и пустой структуры в Go?
```text
Размер: Пустой интерфейс занимает 16 байт на 64-битных архитектурах и 8 байт на 32-битных архитектурах.
Причина: Пустой интерфейс в Go содержит два указателя:
- Типовой указатель: Указывает на информацию о типе значения, которое хранится в интерфейсе.
- Указатель на данные: Указывает на само значение.
  Эти указатели необходимы для того, чтобы интерфейс мог хранить значения любого типа и обеспечивать динамическую диспетчеризацию методов.
```

### 2. Почему размер пустой структуры равен 0 байт?
```text
Поскольку пустая структура не содержит никаких полей, она не занимает места в памяти. Это делает ее полезной для использования в качестве маркера или для реализации интерфейсов без добавления накладных расходов.
```

### 3. - Что произойдет при записи в закрытый канал или чтении из него?
```text
Запись в закрытый канал
Паника: Если вы попытаетесь записать значение в закрытый канал, это вызовет панику (panic). Это связано с тем, что закрытый канал больше не может принимать новые значения, и попытка записи в него считается ошибкой.

Чтение из закрытого канала
Успешное чтение: Если вы читаете из закрытого канала, вы получите нулевое значение типа, который хранится в канале, и второй возвращаемый параметр (если используется) будет равен false, что указывает на то, что канал закрыт и больше не будет значений.
```
Практическое задание:
- https://pastebin.com/raw/hqZfx8Kk
- https://ya.cc/t/lkIIDcjR5n5E9L

```go
// Задача: 
// Есть сервис обработки заказов. Он должен принимать заказы, 
// обрабатывать их и возвращать результат.
// Найдите ошибку в реализации.

package main

import "fmt"

type Order struct {
	ID   int
	Data string
}

func processOrders() {
	orders := make(chan Order)   // канал для заказов
	results := make(chan string) // канал для результатов

	// Горутина для обработки заказов
	go func() {
		for order := range orders {
			// Обработка заказа
			result := fmt.Sprintf("Заказ %d обработан", order.ID)
			results <- result
		}
	}()

	// Основной цикл
	for i := 1; i <= 3; i++ { // 2. нужно выносить во вторую горутину
		orders <- Order{ID: i, Data: "данные"}
		// fmt.Println(<-results) // 1. будет deadlock
	}

	close(orders)
	close(results) // 3. будет паника, если третья первая горутина не успеет все записать
}

func main() {
	processOrders()
}

```

### 4. Можно ли использовать структуру в качестве ключа мапы?
```text
Основные моменты

Сравнимость:
Структуры могут быть использованы в качестве ключей, если все их поля поддерживают операцию сравнения ==. Это включает в себя базовые типы, такие как int, string, bool, и указатели (если они не nil).

Неизменяемость:
Ключи в мапах должны быть неизменяемыми. Если структура используется в качестве ключа, ее поля не должны изменяться после добавления в мапу, иначе это может привести к непредсказуемому поведению.

Использование указателей:
Указатели на структуры не могут быть использованы в качестве ключей, так как указатели сравниваются по адресу, а не по значению.
```
Практическое задание:
- https://pastebin.com/raw/xdxmJyJ4
```go
package main

import (
	"fmt"
)

type Point struct {
	X, Y int
}

func main() {
	// Создаем мапу с ключами типа Point
	points := make(map[Point]string)

	// Создаем указатель на структуру Point
	p1 := &Point{X: 1, Y: 2}

	// Попытка использовать указатель на структуру в качестве ключа
	// Это вызовет ошибку, так как указатели не могут быть ключами в мапе
	points[p1] = "Point A" // 1. *p1 можно

	// Доступ к элементам мапы
	fmt.Println(points[*p1])
}

```

### 5. Какие приметивы синхронизации есть в GO?
```text
1. sync.Mutex         // Мьютексы
2. sync.RWMutex      // Мьютексы с разделением чтения/записи
3. sync.WaitGroup    // Ожидание завершения горутин
4. channels          // Каналы для обмена данными
5. sync.Cond         // Условные переменные
6. sync/atomic       // Атомарные операции
7. context.Context   // Контекст для управления отменой
```
### 6. Какой примитив синхронизации вы бы использовали для обеспечения безопасного доступа к разделяемому ресурсу, который часто читается, но редко изменяется, и почему?
```text
В этом случае я бы использовал sync.RWMutex. Он позволяет нескольким горутинам одновременно читать данные, что улучшает производительность в сценариях, где чтение происходит чаще, чем запись. При необходимости изменения данных RWMutex позволяет заблокировать ресурс для эксклюзивного доступа, предотвращая одновременные записи.
```

### 7. Какой примитив синхронизации вы бы использовали для реализации счетчика, который может быть увеличен несколькими горутинами одновременно, и почему?
```text
Для реализации счетчика, который может быть увеличен несколькими горутинами одновременно, я бы использовал пакет sync/atomic. Он предоставляет атомарные операции, такие как AddInt32, которые позволяют безопасно изменять значение переменной без использования мьютексов. Это обеспечивает высокую производительность и безопасность при конкурентном доступе.
```

### 8. Как под подсчитать количество символов в строке? 
```text
В Go подсчет количества символов в строке может быть выполнен несколькими способами, в зависимости от того, что именно вы хотите подсчитать: байты или символы (руны).
Объяснение
- len(str): Возвращает количество байтов в строке. Это быстро и эффективно, но не учитывает многобайтовые символы.
- utf8.RuneCountInString(str): Возвращает количество рун (символов Unicode) в строке. Это более универсальный способ подсчета символов, особенно если строка может содержать символы, выходящие за пределы ASCII.
```

### 9. Для чего нужне iota оператор?
```text
iota — это специальный идентификатор в Go, который используется для упрощения создания последовательных числовых констант. Он часто используется в блоках const для автоматического присвоения значений константам, начиная с нуля и увеличиваясь на единицу для каждой последующей константы.
```
Практическое задание:
- https://pastebin.com/raw/e8s8Ak42
```go

package main

import (
	"fmt"
)

const X = 2

func main() {
	const (
		X = X + X
		Y
		Z
		F
	)

	fmt.Println(X, Y, Z, F)
}

//X: Будет равно 4, так как X + X равно 2 + 2.
//Y: Будет равно 8, так как Y получает значение X + X, что равно 4 + 4.
//Z: Будет равно 8, так как Z получает значение Y, которое равно 8.
//F: Будет равно 8, так как F получает значение Z, которое равно 8.
//Таким образом, код выведет: 4 8 8 8.

```




## Senior

---
### 1. Как устроены атомарные операции в Go?
```go
Атомарность:
Атомарные операции выполняются как единое целое, без возможности прерывания. Это означает, что они не могут быть разделены на более мелкие шаги, которые могут быть прерваны другими горутинами. Это гарантирует, что операции, такие как инкремент или сравнение и установка, выполняются безопасно в многопоточной среде.

Использование процессорных инструкций:
Атомарные операции в sync/atomic реализованы с использованием специальных процессорных инструкций, которые поддерживают атомарность на уровне аппаратного обеспечения. Эти инструкции позволяют выполнять операции, такие как загрузка, сохранение, добавление и сравнение, без использования блокировок.

Минимальные накладные расходы:
Поскольку атомарные операции не требуют блокировок, они имеют минимальные накладные расходы по сравнению с мьютексами. Это делает их более эффективными для простых операций, таких как инкремент счетчика.
```

### 2. Зачем в структуре объявлять поле вида _. Как его можно использовать?
```text
В Go символ _ используется как "пустое" имя, которое позволяет игнорировать значения. В контексте структуры, поле с именем _ может использоваться для нескольких целей:

Выравнивание и отступы (padding):
Поле _ может быть использовано для добавления отступов в структуре, чтобы обеспечить правильное выравнивание других полей. Это может быть важно для оптимизации производительности, особенно при взаимодействии с низкоуровневыми системами или при использовании структуры в CGo.

Зарезервированное место:
_ может использоваться для резервирования места в структуре, если вы планируете добавить поле позже, но хотите сохранить совместимость с существующим кодом или бинарными интерфейсами.

Игнорирование значений:
Хотя это не относится непосредственно к структурам, _ часто используется для игнорирования возвращаемых значений функций, которые не нужны.


```