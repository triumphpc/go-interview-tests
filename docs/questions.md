# Table of Contents
1. Middle
   1. [1. Какой размер пустого интерфейса и пустой структуры в Go?](#1-какой-размер-пустого-интерфейса-и-пустой-структуры-в-go) 
   2. [2. Почему размер пустой структуры равен 0 байт?](#2-почему-размер-пустой-структуры-равен-0-байт)



# Вопросы для собеседования GO-разработчиков
## Middle

---
### 1. Какой размер пустого интерфейса и пустой структуры в Go?
```text
Размер: Пустой интерфейс занимает 16 байт на 64-битных архитектурах и 8 байт на 32-битных архитектурах.
Причина: Пустой интерфейс в Go содержит два указателя:
- Типовой указатель: Указывает на информацию о типе значения, которое хранится в интерфейсе.
- Указатель на данные: Указывает на само значение.
  Эти указатели необходимы для того, чтобы интерфейс мог хранить значения любого типа и обеспечивать динамическую диспетчеризацию методов.
```

### 2. Почему размер пустой структуры равен 0 байт?
```text
Поскольку пустая структура не содержит никаких полей, она не занимает места в памяти. Это делает ее полезной для использования в качестве маркера или для реализации интерфейсов без добавления накладных расходов.
```

### 3. - Что произойдет при записи в закрытый канал или чтении из него?
```text
Запись в закрытый канал
Паника: Если вы попытаетесь записать значение в закрытый канал, это вызовет панику (panic). Это связано с тем, что закрытый канал больше не может принимать новые значения, и попытка записи в него считается ошибкой.

Чтение из закрытого канала
Успешное чтение: Если вы читаете из закрытого канала, вы получите нулевое значение типа, который хранится в канале, и второй возвращаемый параметр (если используется) будет равен false, что указывает на то, что канал закрыт и больше не будет значений.
```
Практическое задание:
- https://pastebin.com/raw/PpCZyfd2
- https://ya.cc/t/lkIIDcjR5n5E9L

```go
// Задача: 
// Есть сервис обработки заказов. Он должен принимать заказы, 
// обрабатывать их и возвращать результат.
// Найдите ошибку в реализации.

package main

import "fmt"

type Order struct {
   ID   int
   Data string
}

var Results map[Order]string // Не инициировано

func processOrders() {
   orders := make(chan Order) // канал для заказов
   //var results chan string // 1. Не иницирована
   results := make(chan string) // канал для результатов

   // Горутина для обработки заказов
   go func() {
      for order := range orders {
         // Обработка заказа
         result := fmt.Sprintf("Заказ %d обработан", order.ID)
         results <- result

         Results[order] = order.Data // 4. Тут гонка данных
      }
   }()

   // Основной цикл
   for i := 1; i <= 3; i++ { // 2. нужно выносить во вторую горутину
      orders <- Order{ID: i, Data: "данные"}
      // fmt.Println(<-results) // 1. будет deadlock
   }

   close(orders)
   close(results) // 3. будет паника, если третья первая горутина не успеет все записать
}

func main() {
   processOrders()
}


```

### 4. Можно ли использовать структуру в качестве ключа мапы?
```text
Основные моменты

Сравнимость:
Структуры могут быть использованы в качестве ключей, если все их поля поддерживают операцию сравнения ==. Это включает в себя базовые типы, такие как int, string, bool, и указатели (если они не nil).

Неизменяемость:
Ключи в мапах должны быть неизменяемыми. Если структура используется в качестве ключа, ее поля не должны изменяться после добавления в мапу, иначе это может привести к непредсказуемому поведению.

Использование указателей:
Указатели на структуры не могут быть использованы в качестве ключей, так как указатели сравниваются по адресу, а не по значению.
```
Практическое задание:
- https://pastebin.com/raw/dFdQriH1

```go
package main

import "fmt"

type Point struct {
   X, Y int
   Z    *string
}

func main() {
   // Создаем мапу с ключами типа Point
   points := make(map[Point]string)

   // Создаем указатель на структуру Point
   p1 := &Point{X: 1, Y: 2}

   // Попытка использовать указатель на структуру в качестве ключа
   // Это вызовет ошибку, так как указатели не могут быть ключами в мапе
   //points[p1] = "Point A" // 1. *p1 можно

   points[*p1] = "Point A"

   stKey := "Some string"
   //p2 := &Point{Z: stKey} // 2. Тут ошибка, нужно по укзателю
   p2 := &Point{Z: &stKey}

   points[*p2] = "Point B"

   //result1 := &points[*p1] // 3. Получение значения по указателю нельзя в мапе
   result1 := points[*p1]
   result2 := points[*p2]

   fmt.Printf(result1)
   fmt.Printf(result2)
}


```

### 5. Какие приметивы синхронизации есть в GO?
```text
1. sync.Mutex         // Мьютексы
2. sync.RWMutex      // Мьютексы с разделением чтения/записи
3. sync.WaitGroup    // Ожидание завершения горутин
4. channels          // Каналы для обмена данными
5. sync.Cond         // Условные переменные
6. sync/atomic       // Атомарные операции
7. context.Context   // Контекст для управления отменой
```
### 6. Какой примитив синхронизации вы бы использовали для обеспечения безопасного доступа к разделяемому ресурсу, который часто читается, но редко изменяется, и почему?
```text
В этом случае я бы использовал sync.RWMutex. Он позволяет нескольким горутинам одновременно читать данные, что улучшает производительность в сценариях, где чтение происходит чаще, чем запись. При необходимости изменения данных RWMutex позволяет заблокировать ресурс для эксклюзивного доступа, предотвращая одновременные записи.
```

### 7. Какой примитив синхронизации вы бы использовали для реализации счетчика, который может быть увеличен несколькими горутинами одновременно, и почему?
```text
Для реализации счетчика, который может быть увеличен несколькими горутинами одновременно, я бы использовал пакет sync/atomic. Он предоставляет атомарные операции, такие как AddInt32, которые позволяют безопасно изменять значение переменной без использования мьютексов. Это обеспечивает высокую производительность и безопасность при конкурентном доступе.
```

### 8. Как под подсчитать количество символов в строке? 
```text
В Go подсчет количества символов в строке может быть выполнен несколькими способами, в зависимости от того, что именно вы хотите подсчитать: байты или символы (руны).
Объяснение
- len(str): Возвращает количество байтов в строке. Это быстро и эффективно, но не учитывает многобайтовые символы.
- utf8.RuneCountInString(str): Возвращает количество рун (символов Unicode) в строке. Это более универсальный способ подсчета символов, особенно если строка может содержать символы, выходящие за пределы ASCII.
```

### 9. Для чего нужне iota оператор?
```text
iota — это специальный идентификатор в Go, который используется для упрощения создания последовательных числовых констант. Он часто используется в блоках const для автоматического присвоения значений константам, начиная с нуля и увеличиваясь на единицу для каждой последующей константы.
```
Практическое задание:
- https://pastebin.com/raw/e8s8Ak42
```go

package main

import (
	"fmt"
)

const X = 2

func main() {
	const (
		X = X + X
		Y
		Z
		F
	)

	fmt.Println(X, Y, Z, F)
}

//X: Будет равно 4, так как X + X равно 2 + 2.
//Y: Будет равно 8, так как Y получает значение X + X, что равно 4 + 4.
//Z: Будет равно 8, так как Z получает значение Y, которое равно 8.
//F: Будет равно 8, так как F получает значение Z, которое равно 8.
//Таким образом, код выведет: 4 8 8 8.

```

### 10. Тест с захватом переменной
Практическое задание
https://pastebin.com/raw/2WBG5QM5

```go
package main

import "fmt"

func main() {
    var funcs []func()

    for i := 0; i < 3; i++ {
        funcs = append(funcs, func() {
            fmt.Println(i)
        })
    }

    for _, f := range funcs {
        f()
    }
}

```
Почему возникает проблема с захватом переменной в цикле?
```text
Проблема возникает, потому что замыкание захватывает переменную, а не ее значение. В результате, когда замыкание 
выполняется, оно использует текущее значение переменной, которое может измениться после создания замыкания
```

С какой версии Go изменилось поведение захвата переменных в цикле?
```text
В Go 1.21 было введено изменение, которое автоматически создает новую переменную для каждой итерации цикла, если 

переменная используется в замыкании. Это изменение устраняет проблему захвата переменной в цикле без необходимости явного создания новой переменной.
```
### 11. Как в GO реализована парадигма ООП наследование? 
```text
В Go парадигма объектно-ориентированного программирования (ООП) реализуется через композицию, а не через наследование, 
как в некоторых других языках. Композиция в Go позволяет создавать сложные структуры путем объединения более простых 
структур, что делает код более гибким и модульным.


В Go вы можете встраивать одну структуру в другую. Это позволяет встраиваемой структуре "унаследовать" методы и поля 
встраиваемой структуры, что похоже на наследование, но без жесткой иерархии классов.

В Go анонимные поля (или встраиваемые поля) — это поля структуры, которые определяются без явного имени. 
Вместо имени поля указывается только тип. Это позволяет встраивать одну структуру в другую, что является основным 
механизмом композиции в Go.
```
А как реализован полиморфизм?
```text
Полиморфизм позволяет объектам разных классов обрабатывать вызовы методов через один и тот же интерфейс. 
Это достигается за счет реализации методов с одинаковыми именами в разных классах. В Go полиморфизм реализуется через интерфейсы, 
которые позволяют различным типам данных реализовывать один и тот же набор методов.

```

Как в Go называется реализация интерфейсов? В чем его плюсы?
```text
В Go реализация интерфейсов называется утиная типизация (duck typing). Это означает, что тип считается реализацией интерфейса, 
если он предоставляет все методы, определенные в этом интерфейсе, без необходимости явного указания, что он реализует интерфейс.
В Go типы не объявляют, что они реализуют интерфейс. Если тип предоставляет все методы, определенные в интерфейсе, 
он автоматически считается реализацией этого интерфейса.
```

### 12. Тесты по указателям
https://pastebin.com/raw/ht1hbfc0
```go
// Что выведет?
package main

import "fmt"

// Определяем структуру Address
type Address struct {
   City, Country string
}

// Определяем структуру Person с вложенной структурой Address
type Person struct {
   Name    string
   Address Address
}

// Метод для изменения имени
func (p *Person) ChangeName(newName string) {
   p.Name = newName
}

// Метод для изменения города
func (p *Person) ChangeCity(newCity string) {
   p.Address.City = newCity
}

// Функция для изменения страны
func changeCountry(person *Person, newCountry string) {
   person = &Person{
      Address: Address{
         Country: newCountry,
      },
   }

   //person.Address.Country = newCountry
}

func main() {
   // Создаем экземпляр Person
   person := &Person{
      Name: "Bob",
      Address: Address{
         City:    "New York",
         Country: "USA",
      },
   }

   fmt.Println("Before changes:", person.Name, person.Address.City, person.Address.Country)

   // Изменяем имя с помощью метода
   person.ChangeName("Alice")

   // Изменяем город с помощью метода
   person.ChangeCity("Los Angeles")

   // Изменяем страну с помощью функции
   changeCountry(person, "Canada")

   fmt.Println("After changes:", person.Name, person.Address.City, person.Address.Country)

   // Before changes: Bob New York USA
   //After changes: Alice Los Angeles USA
}

```
### 13. Работа с мапами. Практические тесты
```go
package main

import (
	"fmt"
)

// Определяем структуру Point
type Point struct {
	X, Y int
}

func main() {
	// Создаем мапу с ключами типа Point
	points := make(map[Point]string)

	// Добавляем элементы в мапу
	points[Point{X: 1, Y: 2}] = "Point A"
	points[Point{X: 3, Y: 4}] = "Point B"

	// Чтение значения из мапы по существующему ключу
	value, exists := points[Point{X: 1, Y: 2}]
	fmt.Println(value, exists) // Вывод: Point A true

	// Чтение значения из мапы по несуществующему ключу
	value, exists = points[Point{X: 5, Y: 6}]
	fmt.Println(value, exists) // Вывод:  false

	// Ответы на вопросы:
	// 1. Как работают мапы с ключами, которые являются структурами?
	//    - Структуры могут быть использованы в качестве ключей в мапах, если все их поля поддерживают операцию сравнения `==`.
	//    - В данном примере структура Point используется в качестве ключа, и мапа корректно обрабатывает операции вставки и поиска.

	// 2. Что произойдет, если попытаться прочитать значение из мапы по несуществующему ключу?
	//    - Если ключ не существует в мапе, будет возвращено нулевое значение типа значения мапы (в данном случае пустая строка) и `false`.
	//    - Это позволяет легко проверять наличие ключа в мапе.
}
```

Ошибка с указателем в структуре
```go
package main

import (
	"fmt"
)

// Определяем структуру Point с указателем
type Point struct {
	X, Y int
	Z    *int // Указатель в структуре
}

func main() {
	// Попытка создать мапу с ключами типа Point
	points := make(map[Point]string)

	// Ошибка компиляции: invalid map key type Point
	points[Point{X: 1, Y: 2}] = "Point A"

	fmt.Println(points)
}

```

Выставление значения по указателю 

https://pastebin.com/raw/w6BLC1FY
```go

package main

import "fmt"

type Person struct {
	name string
}

func main() {
	// Создаем мапу, где ключи - строки, а значения - структуры Person
	peopleMap := map[string]Person{
		"first": Person{"Alice"},
	}

	// Попытка изменить поле структуры, хранящейся в мапе
	// peopleMap["first"].name = "Bob" // Ошибка: нельзя изменить поле структуры в мапе напрямую

	// Вывод текущего значения поля name
	fmt.Println(peopleMap["first"].name) // Вывод: Alice

	// Извлекаем значение из мапы, изменяем его и записываем обратно
	person := peopleMap["first"] // Извлекаем копию значения из мапы
	person.name = "Bob" // Изменяем поле name в копии

	peopleMap["first"] = person // Записываем измененное значение обратно в мапу
	fmt.Println(peopleMap["first"].name) // Вывод: Bob
}
```

### 14. Как устроены мапы в GO?
```text
- Мапа в Go представляет собой хеш-таблицу, где ключи хешируются для определения их местоположения в таблице.

- Хеш-таблица состоит из бакетов. Каждый бакет может содержать несколько пар ключ-значение. 
Это позволяет уменьшить количество коллизий, так как несколько ключей могут быть помещены в один бакет.

- Для каждого ключа вычисляется хеш, который определяет, в какой бакет будет помещен ключ. 
Хеш-функция должна быть быстрой и равномерно распределять ключи по бакетам.

- Когда мапа увеличивается в размере (например, при добавлении новых элементов), она может потребовать перераспределения 
элементов между бакетами. Это называется эвакуацией.

- Эвакуация происходит, когда мапа увеличивается в два раза. Все элементы из старых бакетов перемещаются в новые бакеты, 
чтобы уменьшить количество коллизий и улучшить производительность.

- Во время эвакуации элементы перераспределяются по новым бакетам на основе их хешей. Это позволяет сохранить 
равномерное распределение ключей и уменьшить количество коллизий.

- Производительность: Мапы в Go обеспечивают амортизированное время доступа O(1) для операций вставки, удаления и поиска, 
что делает их очень эффективными для большинства сценариев использования.

- Коллизии: Использование бакетов позволяет эффективно обрабатывать коллизии, так как несколько ключей могут 
быть помещены в один бакет.

- Эвакуация: Эвакуация позволяет мапам динамически увеличиваться в размере, сохраняя производительность.
```


### 15. Для чего в GO нужны слайсы? И чем они отличаются от массивов? 
```text
Размер:
Массивы: Имеют фиксированный размер, который задается при их создании и не может быть изменен. Например, var arr [5]int 
создает массив из 5 элементов.
Слайсы: Имеют динамический размер. Они могут увеличиваться или уменьшаться в зависимости от потребностей. 
Слайсы являются более гибкими, чем массивы.

Семантика передачи:
Массивы: Передаются по значению, что означает, что при передаче массива в функцию создается его копия.
Слайсы: Передаются по ссылке. Это означает, что слайс указывает на базовый массив, и изменения в слайсе отражаются на базовом массиве.

Использование памяти:
Массивы: Хранят все элементы в непрерывном блоке памяти.
Слайсы: Содержат указатель на базовый массив, длину и емкость. Емкость слайса может быть больше его длины, что позволяет 
добавлять элементы без выделения новой памяти.

Гибкость:
Массивы: Менее гибкие из-за фиксированного размера.
Слайсы: Более гибкие и удобные для работы с динамическими данными. Они поддерживают такие операции, как добавление, удаление и изменение размера.

```

Практические задачи:

https://pastebin.com/raw/LuhiQDqA

```go
// Что выведет код?
package main

import "fmt"

func main() {
	// Инициализация массива
	array := [...]int{0, 1, 2, 3, 4, 5, 6}

	// Создание слайса, который ссылается на часть массива, начиная с индекса 1
	sliceFull := array[1:]
	fmt.Println(sliceFull, len(sliceFull), cap(sliceFull)) // [1, 2, 3, 4, 5, 6] 6 6

	// Создание слайса, который ссылается на часть sliceFull, с длиной 2 и емкостью 4
	slicePartial := sliceFull[:2:4]
	fmt.Println(slicePartial, len(slicePartial), cap(slicePartial)) // [1, 2] 2 4

	// Вывод части sliceFull, начиная с индекса 4
	fmt.Println(sliceFull[4:]) // [5 6]

	// Добавление элементов из sliceFull[4:] в slicePartial
	sliceExtended := append(slicePartial, sliceFull[4:]...)
	fmt.Println(sliceExtended, len(sliceExtended), cap(sliceExtended)) // [1, 2, 5, 6] 4 4

	// Вывод sliceFull после изменения sliceExtended
	fmt.Println(sliceFull, len(sliceFull), cap(sliceFull)) // [1 2 5 6 5 6] 6 6

	// Добавление элемента в sliceExtended
	sliceExtended = append(sliceExtended, 7)
	fmt.Println(sliceExtended, len(sliceExtended), cap(sliceExtended)) // [1, 2, 5, 6, 7] 5 8

	// Вывод sliceFull после изменения sliceExtended
	fmt.Println(sliceFull, len(sliceFull), cap(sliceFull)) // [1 2 5 6 5 6] 6 6

	// Вывод исходного массива
	fmt.Println(array) // [0 1 2 5 6 5 6]
}
```


Что выведет?
Ответ: 1 0
```go

func main() {
	a := []int{1, 2, 3, 2}

	for i, v := range a {
		if v == 2 {
			a = slices.Delete(a, i, i+1)

			continue
		}
		log.Println(v, " ")
	}

}

```


## Senior

---
### 1. Как устроены атомарные операции в Go?
```go
Атомарность:
Атомарные операции выполняются как единое целое, без возможности прерывания. Это означает, что они не могут быть разделены на более мелкие шаги, которые могут быть прерваны другими горутинами. Это гарантирует, что операции, такие как инкремент или сравнение и установка, выполняются безопасно в многопоточной среде.

Использование процессорных инструкций:
Атомарные операции в sync/atomic реализованы с использованием специальных процессорных инструкций, которые поддерживают атомарность на уровне аппаратного обеспечения. Эти инструкции позволяют выполнять операции, такие как загрузка, сохранение, добавление и сравнение, без использования блокировок.

Минимальные накладные расходы:
Поскольку атомарные операции не требуют блокировок, они имеют минимальные накладные расходы по сравнению с мьютексами. Это делает их более эффективными для простых операций, таких как инкремент счетчика.
```

### 2. Зачем в структуре объявлять поле вида _. Как его можно использовать?
```text
В Go символ _ используется как "пустое" имя, которое позволяет игнорировать значения. В контексте структуры, поле с именем _ может использоваться для нескольких целей:

Выравнивание и отступы (padding):
Поле _ может быть использовано для добавления отступов в структуре, чтобы обеспечить правильное выравнивание других полей. Это может быть важно для оптимизации производительности, особенно при взаимодействии с низкоуровневыми системами или при использовании структуры в CGo.

Зарезервированное место:
_ может использоваться для резервирования места в структуре, если вы планируете добавить поле позже, но хотите сохранить совместимость с существующим кодом или бинарными интерфейсами.

Игнорирование значений:
Хотя это не относится непосредственно к структурам, _ часто используется для игнорирования возвращаемых значений функций, которые не нужны.

```

### 3. Что такое смещение полей в структуре го и почему это важно?

```text
Смещение полей в структуре (или "памятное выравнивание") в Go относится к расположению полей в памяти. Это важно для 
оптимизации доступа к данным и обеспечения правильного выравнивания, что может повлиять на производительность.

Производительность:
Современные процессоры оптимизированы для доступа к данным, выровненным по определенным границам (например, 4 или 8 байт). 
Невыровненные данные могут требовать дополнительных операций для доступа, что замедляет выполнение программы.

Совместимость:
Выравнивание может быть важно для взаимодействия с низкоуровневыми системами или при использовании CGo, где ожидается определенное выравнивание данных.

Оптимизация памяти:
Правильное выравнивание может уменьшить количество используемой памяти, так как позволяет избежать "пустых" байтов между полями.
```

### 4. Рассказать про GC
```text
Garbage Collector (GC) в Go — это автоматическая система управления памятью, которая освобождает память, занимаемую объектами, 
которые больше не используются программой. Основная цель GC — предотвратить утечки памяти и обеспечить эффективное использование памяти.

Основные аспекты Garbage Collector в Go

Трассировка и сборка:
Go использует алгоритм трассировки и сборки (mark-and-sweep). Во время фазы "mark" GC определяет, какие объекты все еще 
доступны и используются программой. Во время фазы "sweep" он освобождает память, занимаемую неиспользуемыми объектами.

Параллельность:
GC в Go работает параллельно с программой, что минимизирует паузы в работе программы. Это достигается за счет использования 
нескольких потоков для выполнения сборки мусора.

Три поколения:
Go GC не использует традиционную концепцию поколений, как в некоторых других языках, но он оптимизирован для работы с 
короткоживущими объектами, что делает его эффективным для большинства приложений.

Триггеры сборки:
Сборка мусора запускается автоматически, когда объем выделенной памяти превышает определенный порог. 
Этот порог может быть настроен с помощью переменной окружения GOGC.

Минимизация пауз:
Go GC минимизирует паузы в работе программы, используя инкрементальный подход, который позволяет выполнять сборку мусора частями, 
не блокируя выполнение программы на длительное время.
```

Как запустить принудительно сборку мусора?
```go
// Принудительно запускаем сборку мусора
runtime.GC()
```

Что такое Stop The World?
```text
"Stop the World" (STW) — это термин, используемый в контексте сборки мусора (Garbage Collection, GC), 
который описывает состояние, когда выполнение всех горутин в программе приостанавливается, чтобы позволить сборщику мусора 
выполнить свою работу. Во время STW все операции программы останавливаются, чтобы GC мог безопасно определить, 
какие объекты в памяти больше не используются и могут быть освобождены.

Основные аспекты "Stop the World"

Необходимость:
STW необходимо для обеспечения целостности данных. Во время сборки мусора необходимо гарантировать, что данные не изменяются, 
чтобы GC мог корректно определить, какие объекты все еще используются.

Влияние на производительность:
Паузы STW могут влиять на производительность программы, особенно в системах реального времени или в приложениях с высокими 
требованиями к задержкам. Длительные паузы могут привести к заметным задержкам в обработке запросов.

Минимизация пауз:
Современные сборщики мусора, включая GC в Go, стремятся минимизировать длительность STW-пауз. Это достигается за счет использования 
инкрементальных и параллельных алгоритмов сборки мусора, которые позволяют выполнять большую часть работы без остановки программы.

Go и STW:
В Go сборщик мусора разработан таким образом, чтобы минимизировать STW-паузы. Он использует инкрементальный подход, который 
позволяет выполнять сборку мусора частями, уменьшая время, в течение которого программа должна быть остановлена.

```

### 5. runtime и планировщик в GO
```text
В Go планировщик (scheduler) отвечает за управление выполнением горутин. Он реализует модель GMP (Goroutine, Machine, Processor), 
которая позволяет эффективно распределять горутины по системным потокам.

Goroutine (G):
Горутина — это легковесная нить выполнения, управляемая планировщиком Go. Горутины дешевле и легче, чем системные потоки, и могут быть созданы в большом количестве.
Каждая горутина имеет собственный стек, который динамически изменяется в размере, начиная с 2 КБ.

Machine (M):
Машина (M) представляет собой системный поток (OS thread), который выполняет горутины. M управляет выполнением горутин и взаимодействует с операционной системой для выполнения задач.
M может быть больше, чем количество процессоров (P), но обычно их количество ограничено.

Processor (P):
Процессор (P) — это логический процессор, который управляет выполнением горутин. P содержит очередь готовых к выполнению горутин и предоставляет M горутины для выполнения.
Количество P определяется переменной окружения GOMAXPROCS, которая по умолчанию равна количеству доступных процессоров.

Создание горутины:
Когда создается новая горутина, она помещается в очередь готовых горутин на одном из процессоров (P).

Выполнение горутин:
Каждый процессор (P) назначается одному системному потоку (M), который выполняет горутины из очереди P.
Если горутина блокируется (например, ожидает ввода/вывода), M может переключиться на выполнение другой горутины.

Балансировка нагрузки:
Если один из процессоров (P) завершает выполнение всех своих горутин, он может "украсть" горутины из очереди другого P, чтобы сбалансировать нагрузку.

Параллелизм и конкурентность:
Планировщик Go позволяет выполнять горутины параллельно на нескольких процессорах, если GOMAXPROCS больше 1. 
Это позволяет использовать преимущества многопроцессорных систем.
```

### 6. Что такое инлайнинг? 
```text
Инлайнинг в Go — это оптимизация компилятора, при которой тело функции вставляется непосредственно в место ее вызова. 
Это позволяет уменьшить накладные расходы на вызов функции, такие как сохранение и восстановление состояния стека, 
и может улучшить производительность программы.

Основные аспекты инлайнинга в Go

Уменьшение накладных расходов:
Инлайнинг устраняет необходимость в вызове функции, что может уменьшить накладные расходы, связанные с переходом к функции 
и возвратом из нее.

Улучшение производительности:
Инлайнинг может улучшить производительность, особенно для небольших функций, которые часто вызываются. 
Это позволяет компилятору лучше оптимизировать код, например, устранять ненужные переменные или объединять операции.
Ограничения инлайнинга:

Не все функции могут быть инлайнены. Компилятор Go применяет инлайнинг только к небольшим и простым функциям. 
Например, функции с циклами, рекурсией или сложной логикой обычно не инлайнятся.

Контроль инлайнинга:
Разработчики не могут явно указывать компилятору, какие функции инлайнить. Решение об инлайнинге принимает компилятор 
на основе своих эвристик.

```

### 7. Stack and Heap
```text
Стек (Stack)
Что это: Стек — это область памяти, которая используется для хранения локальных переменных и данных функции. Он организован как структура данных "последний пришел — первый вышел" (LIFO).
Особенности:
Быстрая аллокация и освобождение памяти.
Память автоматически освобождается, когда функция завершает выполнение.
Ограниченный размер, что может привести к переполнению стека, если используется слишком много памяти.

Куча (Heap)
Что это: Куча — это область памяти, которая используется для хранения данных, которые должны существовать дольше, чем время выполнения функции.
Особенности:
Более медленная аллокация и освобождение памяти по сравнению со стеком.
Память освобождается сборщиком мусора (Garbage Collector).
Подходит для данных, которые должны быть доступны из разных функций или горутин.
```

Практическое задание: 

https://pastebin.com/raw/aCqEZ0FE

```go
// Убегает ли переменная в кучу?
// Как можно переписать этот код, чтобы не убежала?
package main

import "fmt"

func createPointer() *int {
	x := 42
	return &x // Переменная x убегает в кучу, так как возвращается указатель на нее
}

func main() {
	ptr := createPointer()
	fmt.Println(*ptr) // Вывод: 42
}

```

Ответ: 
```go
package main

import "fmt"

func calculate() int {
	x := 42
	return x // Переменная x не убегает в кучу, так как возвращается по значению
}

func main() {
	value := calculate()
	fmt.Println(value) // Вывод: 42
}
```

---------------
# Базы данных 
### 1. Зачем нужны NoSQL базы, почему не использовать SQL?
```text

Горизонтальная масштабируемость:
NoSQL базы данных изначально спроектированы для горизонтального масштабирования, что позволяет легко добавлять новые 
серверы для обработки увеличивающихся объемов данных.

Гибкость схемы:
NoSQL базы данных часто не требуют жесткой схемы, что позволяет легко изменять структуру данных и работать с 
неструктурированными или полуструктурированными данными.

Высокая производительность:
NoSQL базы данных оптимизированы для высоких нагрузок и могут обеспечивать высокую производительность при записи и чтении данных.

Поддержка различных типов данных:
NoSQL базы данных поддерживают различные модели данных, такие как документо-ориентированные, графовые, колоночные 
и ключ-значение, что позволяет выбирать наиболее подходящую модель для конкретной задачи.


NoSQL Плюсы:
Гибкость в работе с данными.
Легкость горизонтального масштабирования.
Высокая производительность для определенных типов операций.
Поддержка различных моделей данных.

NoSQL Минусы:
Отсутствие поддержки сложных запросов и транзакций, как в SQL.
Возможные проблемы с консистентностью данных.
Ограниченная поддержка стандартов и инструментов.


SQL Плюсы:
Поддержка сложных запросов и транзакций.
Строгая схема данных обеспечивает целостность данных.
Широкая поддержка стандартов и инструментов.
Хорошо подходит для структурированных данных.

SQL Минусы:
Ограниченная горизонтальная масштабируемость.
Менее гибкая схема данных.
Может быть менее производительной для определенных типов операций.

Примеры NoSQL баз данных
MongoDB: Документо-ориентированная база данных, которая хранит данные в формате JSON-подобных документов. 
Хорошо подходит для приложений, работающих с неструктурированными данными.
Cassandra: Колоночная база данных, разработанная для обработки больших объемов данных на множестве серверов. 
Хорошо подходит для приложений с высокими требованиями к доступности и масштабируемости.
Redis: База данных ключ-значение, которая хранит данные в памяти. Хорошо подходит для кэширования и приложений с высокими 
требованиями к производительности.

Примеры SQL баз данных
PostgreSQL: Реляционная база данных с поддержкой расширенных функций, таких как JSON, полнотекстовый поиск и 
геопространственные данные.
MySQL: Популярная реляционная база данных, широко используемая в веб-приложениях.
SQLite: Встраиваемая реляционная база данных, которая не требует отдельного сервера и часто используется в мобильных приложениях.
```

### 2. Что означает акроним ACID?
```text
ACID — это акроним, который описывает четыре ключевых свойства транзакций в реляционных базах данных. 
Эти свойства гарантируют надежность и целостность данных при выполнении транзакций.

A — Atomicity (Атомарность)
Описание: Атомарность гарантирует, что все операции в рамках транзакции выполняются как единое целое. 
Если какая-либо часть транзакции не может быть завершена, вся транзакция откатывается, и данные возвращаются в исходное состояние.
Пример: При переводе денег между двумя счетами, если списание с одного счета прошло успешно, но зачисление на другой счет не удалось, 
вся транзакция будет отменена, и деньги останутся на исходном счете.

C — Consistency (Согласованность)
Описание: Согласованность гарантирует, что транзакция переводит базу данных из одного согласованного состояния в другое. 
Это означает, что все правила и ограничения базы данных (например, уникальность, внешние ключи) соблюдаются до и после выполнения транзакции.
Пример: Если в базе данных есть ограничение уникальности на столбец, транзакция, которая пытается вставить дублирующее значение, будет отклонена, 
чтобы сохранить согласованность данных.

I — Isolation (Изоляция)
Описание: Изоляция гарантирует, что параллельно выполняемые транзакции не влияют друг на друга. Каждая транзакция должна выполняться так, 
как если бы она была единственной в системе. Это предотвращает проблемы, такие как "грязное чтение" или "потерянные обновления".
Пример: Если одна транзакция обновляет данные, другая транзакция не должна видеть эти изменения, пока первая транзакция не будет завершена.

D — Durability (Долговечность)
Описание: Долговечность гарантирует, что результаты завершенной транзакции сохраняются даже в случае сбоя системы. 
Это достигается за счет записи изменений на диск или в другой постоянный носитель.
Пример: После успешного завершения транзакции по добавлению записи в базу данных, данные должны оставаться доступными 
даже после перезагрузки сервера или сбоя питания.
```

### 3. Рассказать про уровни изоляции в реляционных СУБД
```text

Уровни изоляции в реляционных системах управления базами данных (СУБД) определяют, как транзакции взаимодействуют друг с другом, 
особенно в условиях параллельного выполнения. Они помогают управлять компромиссом между производительностью и целостностью данных. 
В SQL стандарт определяет четыре уровня изоляции:

1. Read Uncommitted (Чтение незафиксированных данных)
Описание: На этом уровне транзакции могут читать изменения, сделанные другими транзакциями, даже если эти изменения еще не зафиксированы. 
Это может привести к "грязному чтению", когда транзакция читает данные, которые могут быть откатаны.
Проблемы: Грязное чтение.
Пример: Транзакция A обновляет значение в таблице, но не фиксирует изменения. Транзакция B читает это обновленное значение. 
Если транзакция A откатывается, транзакция B будет иметь некорректные данные.

2. Read Committed (Чтение зафиксированных данных)
Описание: На этом уровне транзакции могут читать только те изменения, которые были зафиксированы другими транзакциями. 
Это предотвращает грязное чтение, но не защищает от "неповторяющегося чтения".
Проблемы: Неповторяющееся чтение.
Пример: Транзакция A читает значение из таблицы. Транзакция B обновляет это значение и фиксирует изменения. Если транзакция A снова читает то же значение, она может получить другое значение.

3. Repeatable Read (Повторяемое чтение)
Описание: На этом уровне транзакция гарантирует, что если она читает данные, то эти данные не будут изменены другими 
транзакциями до завершения текущей транзакции. Это предотвращает неповторяющееся чтение, но не защищает от "фантомного чтения".
Проблемы: Фантомное чтение.
Пример: Транзакция A читает набор строк, соответствующих определенному критерию. Транзакция B добавляет новую строку, соответствующую этому критерию, и фиксирует изменения. Если транзакция A снова выполняет тот же запрос, она может увидеть новую строку (фантомное чтение).

4. Уровень изоляции Serializable (Сериализуемый) является самым строгим уровнем изоляции в реляционных СУБД.
 Он гарантирует, что транзакции выполняются так, как если бы они были выполнены последовательно, одна за другой, без какого-либо параллелизма. 
 Это предотвращает все возможные проблемы, связанные с параллельным выполнением транзакций, такие как грязное чтение, неповторяющееся чтение и фантомное чтение.
```

### 4. Какие типы индексов есть? 
```text
B-tree (Дерево поиска):
Наиболее распространенный тип индекса, используемый по умолчанию в PostgreSQL. Подходит для большинства операций, включая равенство, диапазоны и сортировку.

Hash (Хеш-индекс):
Используется для операций равенства. Менее распространен, так как B-tree также поддерживает равенство и более универсален.

GIN (Generalized Inverted Index):
Подходит для индексации массивов, JSONB и полнотекстового поиска. Эффективен для поиска элементов в коллекциях.

GiST (Generalized Search Tree):
Поддерживает широкий спектр пользовательских типов данных и запросов, таких как геометрические данные и полнотекстовый поиск.

SP-GiST (Space-Partitioned Generalized Search Tree):
Подходит для данных, которые могут быть разбиты на непересекающиеся подпространства, например, геометрические данные.

BRIN (Block Range INdexes):
Эффективен для очень больших таблиц, где данные имеют физическую локальность. Подходит для временных данных и данных, которые хранятся в порядке.
```

Рассказать как устроен b-tree в PostgreSQL
```text
B-tree (сбалансированное дерево) — это структура данных, которая широко используется в базах данных и файловых системах 
для организации и быстрого поиска данных. B-tree обеспечивает эффективный доступ к данным с помощью операций поиска, вставки и удаления.

Основные характеристики B-tree

Сбалансированность:
Все листья B-tree находятся на одном уровне, что обеспечивает равномерное время доступа к любому элементу. 
Это достигается за счет того, что дерево автоматически балансируется при добавлении и удалении элементов.

Упорядоченность:
Узлы B-tree содержат ключи, которые упорядочены. Это позволяет быстро находить нужный ключ с помощью бинарного поиска внутри узла.

Ветвление:
Каждый узел B-tree может содержать несколько ключей и указателей на дочерние узлы. Это позволяет дереву оставаться 
сбалансированным и минимизировать количество операций ввода-вывода.

Эффективность:
B-tree оптимизировано для работы с дисковыми системами, минимизируя количество операций ввода-вывода за счет использования
 больших узлов, которые могут содержать множество ключей.
 
Структура B-tree
Корневой узел: Начальная точка дерева. Может содержать от 1 до 2t-1 ключей, где t — минимальная степень дерева.
Внутренние узлы: Узлы, которые содержат ключи и указатели на дочерние узлы. Каждый узел может содержать от t-1 до 2t-1 ключей.
Листья: Узлы, которые не имеют дочерних узлов. Все листья находятся на одном уровне.


```

### 4. Какие виды репликаций есть в PG? 
```text
В PostgreSQL существует несколько видов репликации, которые позволяют создавать копии базы данных для повышения доступности,
 отказоустойчивости и масштабируемости. Вот основные виды репликации, поддерживаемые PostgreSQL:

1. Синхронная репликация
Описание: В синхронной репликации изменения, внесенные в основную базу данных, должны быть подтверждены на реплике перед 
фиксацией транзакции. Это гарантирует, что данные на реплике всегда актуальны.
Преимущества: Высокая надежность данных, так как реплика всегда содержит актуальные данные.
Недостатки: Может увеличить задержки транзакций, так как требуется подтверждение от реплики.

2. Асинхронная репликация
Описание: В асинхронной репликации изменения фиксируются в основной базе данных без ожидания подтверждения от реплики. 
Реплика получает изменения с некоторой задержкой.
Преимущества: Высокая производительность, так как транзакции не ждут подтверждения от реплики.
Недостатки: Возможна потеря данных в случае сбоя основной базы данных до того, как изменения будут применены на реплике.

3. Логическая репликация
Описание: Логическая репликация позволяет реплицировать отдельные таблицы или части данных, а не всю базу данных. 
Она основана на публикации и подписке.
Преимущества: Гибкость в выборе данных для репликации, возможность репликации между разными версиями PostgreSQL.
Недостатки: Более сложная настройка по сравнению с физической репликацией.

4. Потоковая репликация (Streaming Replication)
Описание: Потоковая репликация — это форма физической репликации, при которой изменения передаются в реальном времени из основной базы данных на реплику.
Преимущества: Быстрая передача изменений, поддержка как синхронной, так и асинхронной репликации.
Недостатки: Требует постоянного сетевого соединения между основной базой данных и репликой.

5. Физическая репликация
Описание: Физическая репликация создает точную копию основной базы данных на уровне блоков данных. 
Это может быть реализовано с помощью потоковой репликации или репликации на основе файлов WAL (Write-Ahead Logging).
Преимущества: Простота настройки, высокая производительность.
Недостатки: Репликация всей базы данных, отсутствие гибкости в выборе данных для репликации.
```

### 5. Что такое вертикальное масштабирование и что такое горизонтальное масштабирование СУБД?
```text
Горизонтальное масштабирование (Horizontal Scaling)
Описание: Горизонтальное масштабирование, также известное как "масштабирование вширь", включает добавление дополнительных 
серверов или узлов в систему для распределения нагрузки и увеличения емкости.
Как работает: Данные распределяются между несколькими серверами, что позволяет обрабатывать больше запросов одновременно. 
Это может быть реализовано через шардирование, где данные разбиваются на части и хранятся на разных серверах.
Преимущества:
Легкость добавления новых узлов для увеличения емкости.
Высокая отказоустойчивость, так как сбой одного узла не приводит к отказу всей системы.
Возможность обработки больших объемов данных и большого количества запросов.
Недостатки:
Сложность управления и координации между узлами.
Возможные проблемы с консистентностью данных.
Требует изменения архитектуры приложения для поддержки распределенных данных.

Вертикальное масштабирование (Vertical Scaling)
Описание: Вертикальное масштабирование, также известное как "масштабирование вверх", включает увеличение ресурсов 
(например, процессора, памяти, дискового пространства) на существующем сервере.
Как работает: Улучшение производительности достигается за счет увеличения мощности одного сервера, на котором работает СУБД.
Преимущества:
Простота реализации, так как не требует изменения архитектуры приложения.
Поддержка транзакций и консистентности данных на одном сервере.
Легкость управления, так как все данные находятся на одном сервере.
Недостатки:
Ограничения по максимальному размеру и мощности одного сервера.
Возможность единой точки отказа (если сервер выходит из строя, вся система может быть недоступна).
Более высокая стоимость мощного оборудования.

```

А что такое партиционирование и сэмплирование? 
```text

Партиционирование — это процесс разделения большой таблицы на более мелкие, управляемые части, называемые партициями. 
Каждая партиция хранится и управляется отдельно, но логически они все еще представляют собой одну таблицу.

Цели партиционирования:
Улучшение производительности: Позволяет быстрее выполнять запросы, так как операции могут быть ограничены только нужными партициями.
Упрощение управления данными: Позволяет легко управлять данными, например, удалять старые партиции или архивировать их.
Балансировка нагрузки: Разделение данных на партиции может помочь распределить нагрузку на разные диски или узлы.

Типы партиционирования:
Диапазон (Range Partitioning): Данные распределяются по диапазонам значений.
Список (List Partitioning): Данные распределяются по списку значений.
Хэш (Hash Partitioning): Данные распределяются с использованием хеш-функции.
Комбинированное (Composite Partitioning): Использует комбинацию нескольких методов партиционирования.

Сэмплирование
Сэмплирование — это процесс выбора подмножества данных из таблицы для анализа или обработки. 
Это может быть полезно для работы с большими объемами данных, когда полная обработка всех данных нецелесообразна или невозможна.

Цели сэмплирования:
Ускорение анализа: Позволяет быстро получить представление о данных без необходимости обработки всей таблицы.
Экономия ресурсов: Уменьшает нагрузку на систему, так как обрабатывается только часть данных.
Поддержка тестирования и разработки: Позволяет работать с меньшими объемами данных для тестирования и разработки.

Методы сэмплирования:
Случайное сэмплирование: Выборка случайных записей из таблицы.
Систематическое сэмплирование: Выборка записей через равные интервалы.
Стратифицированное сэмплирование: Разделение данных на группы и выборка из каждой группы.

```

### 6. Практическое задание 
```text
Часть 1: Проектирование схемы таблиц
Спроектируйте схему базы данных для библиотеки, включающую таблицы для хранения информации о книгах, авторах, жанрах и читателях.
Должно быть уникальное ограничение на комбинацию reader_id и book_id, чтобы читатель мог взять только одну книгу за раз.

books: Таблица для хранения информации о книгах.
id: Уникальный идентификатор книги.
title: Название книги.
author_id: Идентификатор автора.
genre_id: Идентификатор жанра.
stock: Количество экземпляров книги в наличии.

authors: Таблица для хранения информации об авторах.
id: Уникальный идентификатор автора.
name: Имя автора.

genres: Таблица для хранения информации о жанрах.
id: Уникальный идентификатор жанра.
name: Название жанра (например, поэзия, фантастика).

readers: Таблица для хранения информации о читателях.
id: Уникальный идентификатор читателя.
name: Имя читателя.

borrowed_books: Таблица для отслеживания книг, взятых читателями.
reader_id: Идентификатор читателя.
book_id: Идентификатор книги.
borrow_date: Дата взятия книги.
```

Теперь нужно выборки сделать: 
```text
Задание 1: Выборка количества книг по жанрам с остатком меньше 5
```
```sql
SELECT g.name AS genre_name, 
       COUNT(b.id) AS book_count
FROM genres g
LEFT JOIN books b ON b.genre_id = g.id
WHERE b.stock > 0
GROUP BY g.name
HAVING COUNT(b.id) < 5;
```

```text
Задание 2: Выборка книг жанра "фантастика" и автора "Азимов"

```

```sql
SELECT b.title, 
       a.name AS author_name, 
       g.name AS genre_name, 
       b.stock
FROM books b
JOIN authors a ON b.author_id = a.id
JOIN genres g ON b.genre_id = g.id
WHERE g.name = 'фантастика' AND a.name = 'Азимов' AND b.stock > 0;
```

### 7. Плавающая миграция данных 
```text
Представьте, что у вас есть веб-приложение, которое должно перейти на новую версию базы данных. Как ты это сделаешь? 

```

```text
Плавающая миграция (или "rolling migration") — это процесс обновления системы или базы данных, который выполняется постепенно, 
без остановки всей системы. Этот подход позволяет обновлять компоненты системы поэтапно, минимизируя риск простоев 
и обеспечивая непрерывную доступность сервиса.

Подготовить новую схему:
Добавить новые таблицы или столбцы, необходимые для новой версии, без удаления или изменения существующих данных.

Обновить приложение:
Развернуть новую версию приложения, которая поддерживает как старую, так и новую схему базы данных. 
Используйте флаги функций для управления доступом к новым функциям.

Постепенно переключать пользователей:
Постепенно переводить пользователей на новую версию приложения, начиная с небольшой группы и постепенно увеличивая охват.

Удалить старые данные:
После успешного завершения миграции и уверенности в том, что все работает корректно, удалить старые данные или столбцы, которые больше не нужны.
```


----
## Дизайн и проектирование кода
### 1. Что такое SOLID?
```text
SOLID — это акроним, который описывает пять принципов объектно-ориентированного проектирования, направленных на 
создание более понятного, гибкого и поддерживаемого кода. Эти принципы были предложены Робертом Мартином (Robert C. Martin), 
также известным как "Дядя Боб".

S — Single Responsibility Principle (Принцип единственной ответственности):
Каждый класс или модуль должен иметь одну и только одну причину для изменения, то есть выполнять только одну задачу.

O — Open/Closed Principle (Принцип открытости/закрытости):
Программные сущности должны быть открыты для расширения, но закрыты для модификации.

L — Liskov Substitution Principle (Принцип подстановки Барбары Лисков):
Объекты в программе должны быть заменяемы экземплярами их подтипов без изменения правильности выполнения программы.

I — Interface Segregation Principle (Принцип разделения интерфейса):
Клиенты не должны зависеть от интерфейсов, которые они не используют. Лучше иметь несколько специализированных интерфейсов, чем один общий.

D — Dependency Inversion Principle (Принцип инверсии зависимостей):
Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба типа модулей должны зависеть от абстракций. 
Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
```

### 2. Как в Go обеспечивается D (Dependency Inversion Principle)?
```text
В Go принцип инверсии зависимостей обеспечивается через использование интерфейсов и внедрение зависимостей. 

Интерфейсы:
Интерфейсы в Go позволяют определить набор методов, которые должен реализовать тип. Это позволяет модулям верхнего уровня 
зависеть от интерфейсов, а не от конкретных реализаций.

Внедрение зависимостей:
В Go внедрение зависимостей часто реализуется через конструкторы или функции, которые принимают интерфейсы в качестве параметров. 
Это позволяет передавать зависимости извне, что упрощает тестирование и замену реализаций.
```

```go
package main

import "fmt"

// Определяем интерфейс для отправки уведомлений
type Notifier interface {
	Send(message string) error
}

// Реализация интерфейса для отправки уведомлений по email
type EmailNotifier struct{}

func (e *EmailNotifier) Send(message string) error {
	fmt.Println("Sending email:", message)
	return nil
}

// Функция, использующая интерфейс Notifier для отправки уведомлений
// Внедрение зависимости происходит здесь: функция принимает интерфейс Notifier
// в качестве параметра, что позволяет передавать любую реализацию этого интерфейса.
func NotifyUser(n Notifier, message string) {
	err := n.Send(message)
	if err != nil {
		fmt.Println("Failed to send notification:", err)
	}
}

func main() {
	// Создаем экземпляр EmailNotifier, который реализует интерфейс Notifier
	emailNotifier := &EmailNotifier{}

	// Внедрение зависимости: передаем emailNotifier в функцию NotifyUser
	NotifyUser(emailNotifier, "Hello, User!")
}
```

### 3. А как в GO поддерживается принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP)?
```text
Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP) из SOLID гласит, что объекты в программе должны 
быть заменяемы экземплярами их подтипов без изменения правильности выполнения программы. В контексте Go, где наследование 
не поддерживается напрямую, LSP реализуется через интерфейсы или встраивание структур.
```

Пример нарушения: 
```go
package main

import (
	"fmt"
	"math"
)

// Интерфейс Shape определяет метод Area
type Shape interface {
	Area() float64
}

// Тип Circle реализует интерфейс Shape
type Circle struct {
	Radius float64
}

func (c Circle) Area() float64 {
	return math.Pi * c.Radius * c.Radius
}

// Тип Rectangle реализует интерфейс Shape
type Rectangle struct {
	Width, Height float64
}

func (r Rectangle) Area() float64 {
	return r.Width * r.Height
}

// Ошибочный тип Square, который нарушает LSP
type Square struct {
	Side float64
}

// Ошибка: метод Area возвращает некорректное значение
func (s Square) Area() float64 {
	return -1 // Некорректная реализация
}

// Функция для вывода площади фигуры
func PrintArea(s Shape) {
	fmt.Printf("Area: %.2f\n", s.Area())
}

func main() {
	circle := Circle{Radius: 5}
	rectangle := Rectangle{Width: 4, Height: 3}
	square := Square{Side: 4}

	// Используем функцию PrintArea для разных реализаций интерфейса Shape
	PrintArea(circle)    // Вывод: Area: 78.54
	PrintArea(rectangle) // Вывод: Area: 12.00
	PrintArea(square)    // Вывод: Area: -1.00 (ошибка)
}
```

### 4. Задание на проектирование кода
```text
Требования:
Разработать систему отправки уведомлений. 

Обработка уведомлений:
Уведомления поступают из различных источников и могут иметь разные форматы.
Источники могут быть, например, CSV, JSON и другие.

Отправка уведомлений:
Уведомления должны быть отправлены в различные каналы, такие как email, Telegram и другие.

Расширяемость:
Система должна быть легко расширяемой для добавления новых форматов источников и новых каналов отправки.

Параллельная обработка:
Обработка уведомлений должна быть выполнена параллельно для повышения производительности.
```

```go
package main

import (
   "encoding/csv"
   "encoding/json"
   "fmt"
   "strings"
   "sync"
)

// Постановка задачи:
// Уведомления поступают из различных источников и могут иметь разные форматы (например, CSV и JSON).
// Уведомления должны быть отправлены в различные каналы (например, email, Telegram).
// Система должна быть легко расширяемой для добавления новых форматов источников и новых каналов отправки.
// Обработка уведомлений должна быть выполнена параллельно для повышения производительности.

// NotificationSource определяет интерфейс для источников уведомлений
type NotificationSource interface {
   Parse(data string) Notification
}

// NotificationChannel определяет интерфейс для каналов отправки уведомлений
type NotificationChannel interface {
   Send(notification Notification)
}

// Notification представляет структуру уведомления
type Notification struct {
   Name    string
   Type    string
   ID      string
   Content string
}

// CSVSource реализует интерфейс NotificationSource для CSV данных
type CSVSource struct{}

func (c CSVSource) Parse(data string) Notification {
   reader := csv.NewReader(strings.NewReader(data))
   record, _ := reader.Read()
   return Notification{
      Name:    record[0],
      Type:    record[1],
      ID:      record[2],
      Content: record[3],
   }
}

// JSONSource реализует интерфейс NotificationSource для JSON данных
type JSONSource struct{}

func (j JSONSource) Parse(data string) Notification {
   var notification Notification
   json.Unmarshal([]byte(data), &notification)
   return notification
}

// EmailChannel реализует интерфейс NotificationChannel для отправки email
type EmailChannel struct{}

func (e EmailChannel) Send(notification Notification) {
   fmt.Printf("Sending email to %s with content: %s\n", notification.ID, notification.Content)
}

// TelegramChannel реализует интерфейс NotificationChannel для отправки в Telegram
type TelegramChannel struct{}

func (t TelegramChannel) Send(notification Notification) {
   fmt.Printf("Sending telegram to %s with content: %s\n", notification.ID, notification.Content)
}

// Sender определяет канал отправки уведомлений на основе типа
type Sender struct {
   channels map[string]NotificationChannel
}

func (s *Sender) Send(notification Notification) {
   if channel, exists := s.channels[notification.Type]; exists {
      channel.Send(notification)
   } else {
      fmt.Printf("No channel found for type: %s\n", notification.Type)
   }
}

package main

import (
"encoding/csv"
"encoding/json"
"fmt"
"strings"
"sync"
)

// Постановка задачи:
// Уведомления поступают из различных источников и могут иметь разные форматы (например, CSV и JSON).
// Уведомления должны быть отправлены в различные каналы (например, email, Telegram).
// Система должна быть легко расширяемой для добавления новых форматов источников и новых каналов отправки.
// Обработка уведомлений должна быть выполнена параллельно для повышения производительности.

// NotificationSource определяет интерфейс для источников уведомлений
type NotificationSource interface {
   Parse(data string) Notification
}

// NotificationChannel определяет интерфейс для каналов отправки уведомлений
type NotificationChannel interface {
   Send(notification Notification)
}

// Notification представляет структуру уведомления
type Notification struct {
   Name    string
   Type    string
   ID      string
   Content string
}

// CSVSource реализует интерфейс NotificationSource для CSV данных
type CSVSource struct{}

func (c CSVSource) Parse(data string) Notification {
   reader := csv.NewReader(strings.NewReader(data))
   record, _ := reader.Read()
   return Notification{
      Name:    record[0],
      Type:    record[1],
      ID:      record[2],
      Content: record[3],
   }
}

// JSONSource реализует интерфейс NotificationSource для JSON данных
type JSONSource struct{}

func (j JSONSource) Parse(data string) Notification {
   var notification Notification
   json.Unmarshal([]byte(data), &notification)
   return notification
}

// EmailChannel реализует интерфейс NotificationChannel для отправки email
type EmailChannel struct{}

func (e EmailChannel) Send(notification Notification) {
   fmt.Printf("Sending email to %s with content: %s\n", notification.ID, notification.Content)
}

// TelegramChannel реализует интерфейс NotificationChannel для отправки в Telegram
type TelegramChannel struct{}

func (t TelegramChannel) Send(notification Notification) {
   fmt.Printf("Sending telegram to %s with content: %s\n", notification.ID, notification.Content)
}

// Sender определяет канал отправки уведомлений на основе типа
type Sender struct {
   channels map[string]NotificationChannel
}

func (s *Sender) Send(notification Notification) {
   if channel, exists := s.channels[notification.Type]; exists {
      channel.Send(notification)
   } else {
      fmt.Printf("No channel found for type: %s\n", notification.Type)
   }
}

func main() {
   var wg sync.WaitGroup

   // Примеры данных
   csvData := "Jhon,email,name@example.com,some content"
   jsonData := `{"name":"Alice", "type": "telegram", "id":"@alice", "content":"some content"}`

   // Создаем каналы
   emailChannel := EmailChannel{}
   telegramChannel := TelegramChannel{}

   // Создаем Sender с мапой каналов
   sender := Sender{
      channels: map[string]NotificationChannel{
         "email":    emailChannel,
         "telegram": telegramChannel,
      },
   }

   // Данные для обработки с указанием типа источника
   dataSources := []struct {
      data       string
      sourceType string
   }{
      {csvData, "csv"},
      {jsonData, "json"},
   }

   // Обрабатываем данные из разных источников в параллельных горутинах
   for _, ds := range dataSources {
      wg.Add(1)
      go func(data string, sourceType string) {
         defer wg.Done()

         var source NotificationSource

         // Выбираем источник на основе типа
         switch sourceType {
         case "csv":
            source = CSVSource{}
         case "json":
            source = JSONSource{}
         default:
            fmt.Println("Unknown source type")
            return
         }

         notification := source.Parse(data)
         sender.Send(notification)
      }(ds.data, ds.sourceType)
   }

   // Ожидаем завершения всех горутин
   wg.Wait()
}
```

----
## Редакторы
```text
- Основной – https://codeshare.io/
- https://code.avito.ru/    
- Резерв https://www.online-python.com/
- ! Резерв https://collabedit.com/
- Резерв https://codebunk.com/
- https://code.yandex-team.ru/
- https://workat.tech/

```